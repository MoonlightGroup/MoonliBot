import { Awaitable, BitFieldResolvable, ClientOptions, Snowflake, Client, ClientEvents, Message, User, TextChannel, GuildMember, Guild, CommandInteraction, Collection, SlashCommandBuilder, PermissionResolvable, Channel } from "discord.js";

interface ErineEvents extends ClientEvents {
    contextError: [ctx: Context]
}

interface ErineOptions extends ClientOptions {
    prefix: string | CallableFunction
    guildOnly?: boolean
    owners?: Snowflake[]
}

interface SkyfoldManagerOptions {
    client: ErineClient
}

interface ErineCollected {
    PrefixType: Collection<string, Command> | null
    HybridType: Collection<string, Command<'HybridType'>> | null
    SlashType: Collection<string, Command<'SlashType'>> | null
    HybridGroupType: Collection<string, Command<'HybridGroupType'>> | null
}

interface Event {
    name: keyof ErineEvents
    code: (...args) => Promise<any>
}

interface Interaction {
    name: string;
    code: (...args) => Promise<any>
}

type Plugin = AsyncFunction<Context, boolean> | SyncFunction<Context, boolean> | Promise<(ctx: Context) => Promise<boolean>>

interface CommandStructures {
    PrefixType: {
        data: PrefixBuilder
        params?: ParamsBuilder
        plugins?: Plugin[]
        code: (ctx: Context) => Promise<void>
    }
    HybridType: {
        data: HybridBuilder
        params?: ParamsBuilder
        plugins?: Plugin[]
        code: (ctx: Context) => Promise<void>
    }
    SlashType: {
        data: SlashCommandBuilder
        params?: ParamsBuilder
        plugins?: Plugin[]
        code: (ctx: Context) => Promise<void>
    }
    HybridGroupType: {
        data: HybridGroup
    }
}

enum Types {
    Prefix = 'PrefixType',
    Hybrid = 'HybridType',
    HybridGroup = 'HybridGroupType',
    Slash = 'SlashType'
}

interface BaseParam {
    name: string
    description: string
    required: boolean
    type?: ApplicationCommandOptionType
    value?: any
    long?: boolean
}

type AsyncFunction<S, T> = (args: S) => Promise<T>
type SyncFunction<S, T> = (args: S) => T

type Command<K extends keyof CommandStructures = 'PrefixType'> = CommandStructures[K]

class Skyfold {
    public client: ErineClient
    public commands: ErineCollected
    public interactions: Collection<string, Interaction> | null
    public listeners: Collection<string, Event> | null
    constructor(options: SkyfoldManagerOptions)
    load_commands(dir: string): Promise<void>
    load_events(dir: string): Promise<void>
    load_interactions(dir: string): Promise<void>
    sync(token: string, app_id: string): Promise<void>
}

class Context {
    private data;
    args: string[] | null;
    bot: ErineClient;
    params: BaseParam[] | null;
    parent: Command<Types.HybridGroup> | null;
    command: Command<Types> | null;
    constructor(data: CommandInteraction | Message, bot: ErineClient);
    get message(): Message | null;
    get interaction(): CommandInteraction | null;
    get author(): User;
    get channel(): TextBasedChannel | null;
    get member(): GuildMember | null;
    get guild(): Guild | null;
    send(options: string | MessagePayload | MessageCreateOptions | InteractionReplyOptions): Promise<Message | null>;
    defer(options?: {
        ephemeral?: boolean;
    }): Promise<void | InteractionResponse>;
    get<T>(param: string, defaultValue?: any): T | null;
}

class Coreback {
    client: ErineClient;
    constructor(client: ErineClient);
    isType<T, R>(obj: any, func: (obj: R) => boolean): obj is T;
    getMember(query: string, guild: Guild): Promise<GuildMember | null>;
    getChannel(query: string, guild: Guild): Promise<import("discord.js").CategoryChannel | import("discord.js").NewsChannel | import("discord.js").StageChannel | import("discord.js").TextChannel | import("discord.js").PublicThreadChannel<boolean> | import("discord.js").VoiceChannel | import("discord.js").ForumChannel | null>;
    getRole(query: string, guild: Guild): Promise<import("discord.js").Role | null>;
    convertParamType(input: string, param: BaseParam, ctx: Context): Promise<{
        break: boolean;
        value: any;
    }>;
}

export interface DataHybridBuilder {
    name: string
    aliases?: string[]
    description?: string
}
export interface StringParam extends BaseParam {
    choices?: { name: string, value: string }[]
    max_length?: number
    min_length?: number
}

export interface NumberParam extends BaseParam {
    max_value?: number
    min_value?: number
    choices?: { name: string, value: string }[]
}

export interface ChannelParam extends BaseParam {
    channel_types?: ChannelType[]
}
export interface DataPrefixBuilder {
    names: string[]
    description?: string | null
    usage?: string | null
    cooldown?: number
    category?: string | null
    extra?: any
}

class MissingPermission { ctx: Context; permission: PermissionResolvable; constructor(context: Context, perm: PermissionResolvable)}
class MissingChannelPermission { ctx: Context; permissions: PermissionResolvable; channel: Channel; constructor(context: Context, perm: PermissionResolvable, channel: Channel) }
class MissingBotPermission { ctx: Context; permission: PermissionResolvable; constructor(context: Context, perm: PermissionResolvable) }
class MissingBotChannelPermission { ctx: Context; permissions: PermissionResolvable; channel: Channel; constructor(context: Context, perm: PermissionResolvable, channel: Channel) }
class GuildOnly { ctx: Context; constructor(context: Context); get user(): any}
class NotOwner { ctx: Context; constructor(context: Context); get user(): any}
class CommandNotFound { ctx: Context; provided: string; constructor(context: Context, provided: string)}
class UnknownCommandError { ctx: Context; error: any; constructor(context: Context, error: any)}
class MissingRequiredParam { ctx: Context; param: BaseParam; constructor(context: Context, param: BaseParam)}
class NotParamNumber { ctx: Context; param: BaseParam; constructor(context: Context, param: BaseParam)}
class NotParamBoolean { ctx: Context; param: BaseParam; constructor(context: Context, param: BaseParam)}
class InvalidParamChoice { ctx: Context; param: BaseParam; choices: { name: string; value: any}[]; constructor(context: Context, param: BaseParam, choices: { name: string; value: any}[])}
class InvalidParamMember { ctx: Context; param: BaseParam; constructor(context: Context, param: BaseParam)}
class InvalidParamChannel { ctx: Context; param: BaseParam;constructor(context: Context, param: BaseParam)}
class InvalidParamRole { ctx: Context; param: BaseParam; constructor(context: Context, param: BaseParam)}
class InvalidChannelType { ctx: Context; param: ChannelParam; provided: ChannelType; expected: ChannelType[]; constructor(context: Context, param: ChannelParam, provided: ChannelType, expected: ChannelType[])}
class NotInChannelType { ctx: Context; types: ChannelType[]; channel: Channel; constructor(ctx: Context, types: ChannelType[], channel: Channel) }
class NotNSFW { ctx: Context; constructor(context: Context) }
class OnlyForIDs { ctx: Context; snowflakes: Snowflake[]; constructor(context: Context, snowflakes: Snowflake[]) }

const Errors: {
    MissingPermission: MissingPermission
    MissingChannelPermission: MissingChannelPermission
    MissingBotPermission: MissingBotPermission
    MissingBotChannelPermission: MissingBotChannelPermission
    GuildOnly: GuildOnly
    NotOwner: NotOwner
    CommandNotFound: CommandNotFound
    UnknownCommandError: UnknownCommandError
    MissingRequiredParam: MissingRequiredParam
    NotParamNumber: NotParamNumber
    NotParamBoolean: NotParamBoolean
    InvalidParamChoice: InvalidParamChoice
    InvalidParamMember: InvalidParamMember
    InvalidParamChannel: InvalidParamChannel
    InvalidParamRole: InvalidParamRole
    InvalidChannelType: InvalidChannelType
    NotInChannelType: NotInChannelType
    NotNSFW: NotNSFW
    OnlyForIDs: OnlyForIDs
}

const Plugins: {
    hasAnyPerms(...perms: PermissionResolvable[]): Promise<(ctx: Context) => Promise<boolean>>;
    hasPerms(...perms: PermissionResolvable[]): Promise<(ctx: Context) => Promise<boolean>>;
    hasAnyBotPerms(...perms: PermissionResolvable[]): Promise<(ctx: Context) => Promise<boolean>>;
    hasAnyBotPermsInChannel(...perms: PermissionResolvable[]): Promise<(ctx: Context) => Promise<boolean>>;
    hasBotPerms(...perms: PermissionResolvable[]): Promise<(ctx: Context) => Promise<boolean>>;
    hasBotPermsInChannel(...perms: PermissionResolvable[]): Promise<(ctx: Context) => Promise<boolean>>;
    hasAnyPermsInChannel(...perms: PermissionResolvable[]): Promise<(ctx: Context) => Promise<boolean>>;
    hasPermsInChannel(...perms: PermissionResolvable[]): Promise<(ctx: Context) => Promise<boolean>>;
    isGuild(ctx: Context): Promise<boolean>;
    isInChannelType(ctx: Context): Promise<boolean>;
    isNSFW(ctx: Context): Promise<boolean>;
    isOwner(ctx: Context): Promise<boolean>;
    onlyForIDs(...snowflakes: Snowflake[]): Promise<(ctx: Context) => Promise<boolean>>;
}

class HybridBuilder {
    name: string;
    aliases: string[];
    description: string;
    constructor(options?: DataHybridBuilder);
    setName(name: string): HybridBuilder;
    setDescription(description: string): HybridBuilder;
    setAliases(...aliases: string[]): HybridBuilder;
    toJSON(): {
        name: string;
        description: string;
    };
}

class HybridGroup {
    name: string;
    description: string;
    commands: Command<Types.Hybrid>[];
    constructor();
    setName(name: string): HybridGroup;
    setDescription(description: string): HybridGroup;
    addCommand(command: Command<Types.Hybrid>): HybridGroup;
    toJSON(): {
        name: string;
        description: string;
        options: any[];
    };
}

class ParamsBuilder {
    strings: StringParam[];
    numbers: NumberParam[];
    params: BaseParam[];
    constructor();
    addString(param: StringParam): ParamsBuilder;
    addNumber(param: NumberParam): ParamsBuilder;
    addBoolean(param: BaseParam): ParamsBuilder;
    addMember(param: BaseParam): ParamsBuilder;
    addChannel(param: ChannelParam): ParamsBuilder;
    addRole(param: BaseParam): ParamsBuilder;
}

class PrefixBuilder {
    names: string[];
    description: string | null;
    usage: string | null;
    cooldown?: number;
    category: string | null;
    extra: any;
    constructor(data?: DataPrefixBuilder);
    setNames(...names: string[]): PrefixBuilder;
    setDescription(data: string): PrefixBuilder;
    setUsage(data: string): PrefixBuilder;
    setCooldown(cooldown: number): PrefixBuilder;
    setExtra(data: any): PrefixBuilder;
}

class ErineClient extends Client {
    constructor(options: ErineOptions)
    public skyfold: Skyfold
    public _options: ErineOptions
    public coreback: Coreback
    public load_events(dir: string): Promise<void>
    public load_commands(dir: string): Promise<void>
    public on<K extends keyof ErineEvents>(event: K, listener: (...args: ErineEvents[K]) => Awaitable<void>): this;
    public on<S extends string | symbol>(event: Exclude<S, keyof ErineEvents>, listener: (...args: any[]) => Awaitable<void>): this;
}

export {
    ErineEvents,
    ErineOptions,
    SkyfoldManagerOptions,
    ErineCollected,
    Event,
    Interaction,
    Plugin,
    CommandStructures,
    Types,
    BaseParam,
    AsyncFunction,
    SyncFunction,
    Command,
    ErineClient,
    Skyfold,
    Context,
    Coreback,
    HybridBuilder,
    HybridGroup,
    ParamsBuilder,
    PrefixBuilder,
    Errors,
    Plugins
}