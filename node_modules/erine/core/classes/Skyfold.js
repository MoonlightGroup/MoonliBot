"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Skyfold = void 0;
const discord_js_1 = require("discord.js");
const node_fs_1 = require("node:fs");
const path_1 = require("path");
const Base_1 = require("./Base");
const HybridBuilder_1 = require("./builders/HybridBuilder");
const HybridGroupBuilder_1 = require("./builders/HybridGroupBuilder");
const PrefixBuilder_1 = require("./builders/PrefixBuilder");
class Skyfold {
    client;
    commands;
    interactions;
    listeners;
    constructor(options) {
        if (!(options?.client instanceof Base_1.ErineClient))
            throw new SyntaxError("Invalid client provided in options");
        this.client = options.client;
        this.commands = { PrefixType: null, HybridType: null, SlashType: null, HybridGroupType: null };
        this.interactions = new discord_js_1.Collection();
        this.listeners = null;
    }
    async load_commands(dir) {
        if (!dir)
            throw new SyntaxError("Missing directory to load commands");
        const MODULES = (0, node_fs_1.readdirSync)((0, path_1.join)(process.cwd(), dir));
        for (const file of MODULES) {
            if ((0, node_fs_1.lstatSync)((0, path_1.join)(process.cwd(), dir, file)).isDirectory()) {
                this.load_commands((0, path_1.join)(dir, file));
                continue;
            }
            delete require.cache[(0, path_1.join)(process.cwd(), dir, file)];
            let cmd = require((0, path_1.join)(process.cwd(), dir, file)).body;
            if (!cmd)
                continue;
            if (this.client.coreback.isType(cmd, c => c.data instanceof PrefixBuilder_1.PrefixBuilder)) {
                if (!this.commands.PrefixType)
                    this.commands.PrefixType = new discord_js_1.Collection();
                this.commands.PrefixType.set(cmd.data.names[0], cmd);
            }
            else if (this.client.coreback.isType(cmd, c => c.data instanceof HybridBuilder_1.HybridBuilder)) {
                if (!this.commands.HybridType)
                    this.commands.HybridType = new discord_js_1.Collection();
                this.commands.HybridType.set(cmd.data instanceof PrefixBuilder_1.PrefixBuilder ? cmd.data.names[0] : cmd.data.name, cmd);
            }
            else if (this.client.coreback.isType(cmd, c => c.data instanceof discord_js_1.SlashCommandBuilder)) {
                if (!this.commands.SlashType)
                    this.commands.SlashType = new discord_js_1.Collection();
                this.commands.SlashType.set(cmd.data.name, cmd);
            }
            else if (this.client.coreback.isType(cmd, cmd => cmd.data instanceof HybridGroupBuilder_1.HybridGroup)) {
                if (!this.commands.HybridGroupType)
                    this.commands.HybridGroupType = new discord_js_1.Collection();
                this.commands.HybridGroupType.set(cmd.data.name, cmd);
            }
        }
    }
    async load_events(dir) {
        if (!dir)
            throw new SyntaxError("Missing directory to load events");
        const MODULES = (0, node_fs_1.readdirSync)((0, path_1.join)(process.cwd(), dir));
        for (const file of MODULES) {
            if ((0, node_fs_1.lstatSync)((0, path_1.join)(process.cwd(), dir, file)).isDirectory()) {
                this.load_events((0, path_1.join)(dir, file));
                continue;
            }
            let event = require((0, path_1.join)(process.cwd(), dir, file)).event;
            if (!event)
                continue;
            this.client.on(event.name, event.code);
        }
    }
    async load_interactions(dir) {
        if (!dir)
            throw new SyntaxError("Missing directory to load interactions");
        const MODULES = (0, node_fs_1.readdirSync)((0, path_1.join)(process.cwd(), dir));
        for (const file of MODULES) {
            if ((0, node_fs_1.lstatSync)((0, path_1.join)(process.cwd(), dir, file)).isDirectory()) {
                this.load_interactions((0, path_1.join)(dir, file));
                continue;
            }
            let interaction = require((0, path_1.join)(process.cwd(), dir, file)).interaction;
            if (!interaction)
                continue;
            this.interactions?.set(interaction.name, interaction);
        }
    }
    async sync(token, app_id) {
        const rest = new discord_js_1.REST({ version: "10" }).setToken(token);
        let slash = this.commands.SlashType?.map(s => s.data.toJSON());
        let hybrid = this.commands.HybridType;
        let hybrid_groups = this.commands.HybridGroupType;
        let parsed = [];
        if (hybrid) {
            hybrid.forEach(x => {
                let obj = x.data.toJSON();
                obj.options = x.params?.params || [];
                parsed.push(obj);
            });
        }
        if (hybrid_groups) {
            hybrid_groups.forEach(x => {
                let obj = x.data.toJSON();
                let subs = [];
                for (const y of x.data.commands) {
                    let obj2 = y.data.toJSON();
                    obj2.options = y.params?.params || [];
                    obj2.type = 1;
                    subs.push(obj2);
                }
                obj.options = subs;
                parsed.push(obj);
            });
        }
        let f = (slash || []).concat(parsed);
        let final = slash && hybrid ? slash.concat(parsed) : slash && !hybrid ? slash : parsed;
        rest.put(discord_js_1.Routes.applicationCommands(app_id), {
            body: f
        });
    }
}
exports.Skyfold = Skyfold;
