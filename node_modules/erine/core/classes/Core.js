"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugins = exports.Coreback = void 0;
const tslib_1 = require("tslib");
const discord_js_1 = require("discord.js");
const Errors = tslib_1.__importStar(require("./Errors"));
class Coreback {
    client;
    constructor(client) {
        if (!client)
            throw new SyntaxError('Missing client');
        this.client = client;
    }
    isType(obj, func) {
        return func(obj);
    }
    async getMember(query, guild) {
        if (!query)
            return null;
        let some_id = query.replace(/[^\d]/g, '');
        let member = some_id ? guild.members.cache.get(some_id) || (await guild.members.fetch(some_id).catch(e => null)) : null;
        if (!member)
            member = (guild.members.cache.find(m => m.user.username.includes(query)) || null);
        return member;
    }
    async getChannel(query, guild) {
        if (!query)
            return null;
        let some_id = query.replace(/[^\d]/g, '');
        let channel = some_id ? guild.channels.cache.get(some_id) || (await guild.channels.fetch(some_id).catch(e => null)) : null;
        if (!channel)
            channel = (guild.channels.cache.find(c => c.name.includes(query)) || null);
        return channel;
    }
    async getRole(query, guild) {
        if (!query)
            return null;
        let some_id = query.replace(/[^\d]/g, '');
        let role = some_id ? guild.roles.cache.get(some_id) || (await guild.roles.fetch(some_id).catch(e => null)) : null;
        if (!role)
            role = (guild.roles.cache.find(r => r.name.includes(query)) || null);
        return role;
    }
    async convertParamType(input, param, ctx) {
        if (!input)
            return { break: false, value: null };
        if (param.choices?.length) {
            let found = param.choices.find(x => x.name.toLowerCase() == input.toLowerCase());
            if (!found) {
                ctx.bot.emit('contextError', new Errors.InvalidParamChoice(ctx, param, param.choices));
                return { break: true, value: null };
            }
            else
                return { break: false, value: found.value };
        }
        if (param.type === discord_js_1.ApplicationCommandOptionType.String)
            return { break: false, value: input };
        else if (param.type === discord_js_1.ApplicationCommandOptionType.Number) {
            let n = Number(input);
            if (isNaN(n)) {
                ctx.bot.emit('contextError', new Errors.NotParamNumber(ctx, param));
                return { break: true, value: null };
            }
            else
                return { break: false, value: Number(input) };
        }
        else if (param.type === discord_js_1.ApplicationCommandOptionType.Boolean) {
            let b = input === 'false' ? false : input === 'true' ? true : null;
            if (b === null) {
                ctx.bot.emit('contextError', new Errors.NotParamBoolean(ctx, param));
                return { break: true, value: null };
            }
            else
                return { break: false, value: b };
        }
        else if (param.type === discord_js_1.ApplicationCommandOptionType.User) {
            let b = await this.getMember(input, ctx.guild);
            if (!b) {
                ctx.bot.emit('contextError', new Errors.InvalidParamMember(ctx, param));
                return { break: true, value: null };
            }
            else
                return { break: false, value: b };
        }
        else if (param.type === discord_js_1.ApplicationCommandOptionType.Channel) {
            let b = await this.getChannel(input, ctx.guild);
            if (!b) {
                ctx.bot.emit('contextError', new Errors.InvalidParamChannel(ctx, param));
            }
            else {
                if (param.channel_types && !param.channel_types.includes(b.type)) {
                    ctx.bot.emit('contextError', new Errors.InvalidChannelType(ctx, param, b.type, param.channel_types));
                    return { break: true, value: null };
                }
                return { break: false, value: b };
            }
        }
        else if (param.type === discord_js_1.ApplicationCommandOptionType.Role) {
            let b = await this.getRole(input, ctx.guild);
            if (!b) {
                ctx.bot.emit('contextError', new Errors.InvalidParamRole(ctx, param));
                return { break: true, value: null };
            }
            else
                return { break: false, value: b };
        }
        return { break: false, value: null };
    }
}
exports.Coreback = Coreback;
const Plugins = {
    async isGuild(ctx) {
        if (ctx.channel?.type == discord_js_1.ChannelType.DM) {
            ctx.bot.emit('contextError', new Errors.GuildOnly(ctx));
            return false;
        }
        else
            return true;
    },
    async isInChannelType(...types) {
        return (async (ctx) => {
            let channel = ctx.channel;
            if (!types.includes(ctx.channel?.type)) {
                ctx.bot.emit('contextError', new Errors.NotInChannelType(ctx, types, channel));
                return false;
            }
            else
                return true;
        });
    },
    async isNSFW(ctx) {
        if (!ctx.channel.nsfw) {
            ctx.bot.emit('contextError', new Errors.NotNSFW(ctx));
            return false;
        }
        else
            return true;
    },
    async isOwner(ctx) {
        if (!ctx.bot._options.owners?.includes(ctx.author.id)) {
            ctx.bot.emit('contextError', new Errors.NotOwner(ctx));
            return false;
        }
        else
            return true;
    },
    async hasAnyBotPerms(...perms) {
        return (async (ctx) => {
            if (!perms.some((perm) => (ctx.guild?.members.me).permissions.has(perm))) {
                ctx.bot.emit('contextError', new Errors.MissingBotPermission(ctx, perms));
                return false;
            }
            else
                return true;
        });
    },
    async hasBotPerms(...perms) {
        return (async (ctx) => {
            if (!perms.every((perm) => (ctx.guild?.members.me).permissions.has(perm))) {
                ctx.bot.emit('contextError', new Errors.MissingBotPermission(ctx, perms));
                return false;
            }
            else
                return true;
        });
    },
    async hasAnyPerms(...perms) {
        return (async (ctx) => {
            if (!perms.some((perm) => ctx.member.permissions.has(perm))) {
                ctx.bot.emit('contextError', new Errors.MissingPermission(ctx, perms));
                return false;
            }
            else
                return true;
        });
    },
    async hasPerms(...perms) {
        return (async (ctx) => {
            if (!perms.every((perm) => ctx.member.permissions.has(perm))) {
                ctx.bot.emit('contextError', new Errors.MissingPermission(ctx, perms));
                return false;
            }
            else
                return true;
        });
    },
    async hasAnyBotPermsInChannel(...perms) {
        return (async (ctx) => {
            let channel = ctx.channel;
            let bot = ctx.guild?.members.me;
            let channelPermissions = channel.permissionsFor(bot);
            if (!perms.some((perm) => channelPermissions.has(perm))) {
                ctx.bot.emit('contextError', new Errors.MissingBotChannelPermission(ctx, perms, channel));
                return false;
            }
            else
                return true;
        });
    },
    async hasBotPermsInChannel(...perms) {
        return (async (ctx) => {
            let channel = ctx.channel;
            let bot = ctx.guild?.members.me;
            let channelPermissions = channel.permissionsFor(bot);
            if (!perms.every((perm) => channelPermissions.has(perm))) {
                ctx.bot.emit('contextError', new Errors.MissingBotChannelPermission(ctx, perms, channel));
                return false;
            }
            else
                return true;
        });
    },
    async hasAnyPermsInChannel(...perms) {
        return (async (ctx) => {
            let channel = ctx.channel;
            let channelPermissions = channel.permissionsFor(ctx.author.id);
            if (!perms.some((perm) => channelPermissions.has(perm))) {
                ctx.bot.emit('contextError', new Errors.MissingChannelPermission(ctx, perms, channel));
                return false;
            }
            else
                return true;
        });
    },
    async hasPermsInChannel(...perms) {
        return (async (ctx) => {
            let channel = ctx.channel;
            let channelPermissions = channel.permissionsFor(ctx.author.id);
            if (!perms.every((perm) => channelPermissions.has(perm))) {
                ctx.bot.emit('contextError', new Errors.MissingChannelPermission(ctx, perms, channel));
                return false;
            }
            else
                return true;
        });
    },
    async onlyForIDs(...snowflakes) {
        return (async (ctx) => {
            if (!snowflakes.includes(ctx.author.id)) {
                ctx.bot.emit('contextError', new Errors.OnlyForIDs(ctx, snowflakes));
                return false;
            }
            else
                return true;
        });
    }
};
exports.Plugins = Plugins;
