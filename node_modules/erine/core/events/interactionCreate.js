"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.event = void 0;
const tslib_1 = require("tslib");
const discord_js_1 = require("discord.js");
const Context_1 = require("../classes/Context");
const Errors = tslib_1.__importStar(require("../classes/Errors"));
const types_1 = require("util/types");
const event = {
    name: 'interactionCreate',
    async code(int, bot) {
        if (int.type === discord_js_1.InteractionType.ApplicationCommand) {
            let ctx = new Context_1.Context(int, bot);
            if (bot._options.guildOnly && !int.guild)
                return bot.emit('contextError', new Errors.GuildOnly(ctx));
            let slash_command = bot.skyfold.commands.SlashType?.find(c => c.data.name === int.commandName);
            let hybrid_command = bot.skyfold.commands.HybridType?.find(c => c.data.name === int.commandName);
            if (slash_command && slash_command.plugins) {
                for (const plugin of slash_command.plugins) {
                    if ((0, types_1.isPromise)(plugin)) {
                        if (!(await (await plugin)(ctx)))
                            return;
                    }
                    else {
                        if (!await plugin(ctx))
                            return;
                    }
                }
            }
            if (hybrid_command && hybrid_command.plugins) {
                for (const plugin of hybrid_command.plugins) {
                    if ((0, types_1.isPromise)(plugin)) {
                        if (!(await (await plugin)(ctx)))
                            return;
                    }
                    else {
                        if (!await plugin(ctx))
                            return;
                    }
                }
            }
            let hybrid_group = bot.skyfold.commands.HybridGroupType?.find(c => c.data.name.toLocaleLowerCase() == int.commandName);
            if (!slash_command && !hybrid_command && !hybrid_group)
                return bot.emit('contextError', new Errors.CommandNotFound(ctx, int.commandName));
            let sub = hybrid_group && int.options?.data?.[0]?.type == 1 ? hybrid_group.data.commands.find(c => c.data.name === int.options.data[0].name) : null;
            if (sub && sub.plugins) {
                for (const plugin of sub.plugins) {
                    if ((0, types_1.isPromise)(plugin)) {
                        if (!(await (await plugin)(ctx)))
                            return;
                    }
                    else {
                        if (!await plugin(ctx))
                            return;
                    }
                }
            }
            try {
                if (slash_command)
                    slash_command.code(ctx).catch(e => bot.emit('contextError', new Errors.UnknownCommandError(ctx, e)));
                if (hybrid_command)
                    hybrid_command.code(ctx).catch(e => bot.emit('contextError', new Errors.UnknownCommandError(ctx, e)));
                if (sub)
                    sub.code(ctx).catch(e => bot.emit('contextError', new Errors.UnknownCommandError(ctx, e)));
            }
            catch (e) {
                bot.emit('contextError', new Errors.UnknownCommandError(ctx, e));
            }
        }
        else {
            let interaction = bot.skyfold.interactions?.get(int.customId);
            if (!interaction)
                return;
            let ctx = new Context_1.Context(int, bot);
            try {
                interaction.code(ctx);
            }
            catch (e) {
                bot.emit('contextError', new Errors.UnknownCommandError(ctx, e));
            }
        }
    }
};
exports.event = event;
