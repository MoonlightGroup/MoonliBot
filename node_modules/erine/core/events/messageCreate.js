"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.event = void 0;
const tslib_1 = require("tslib");
const types_1 = require("util/types");
const Context_1 = require("../classes/Context");
const Errors = tslib_1.__importStar(require("../classes/Errors"));
async function LoadPrefixCommand(ctx, prefix_command, args) {
    if (!prefix_command)
        return;
    ctx.command = prefix_command;
    if (prefix_command.plugins) {
        for (const plugin of prefix_command.plugins) {
            if ((0, types_1.isPromise)(plugin)) {
                if (!(await (await plugin)(ctx)))
                    return;
            }
            else {
                if (!await plugin(ctx))
                    return;
            }
        }
    }
    if (prefix_command) {
        if (prefix_command.params) {
            let missing = prefix_command.params.params.find((x, i) => !args[i] && x.required);
            if (missing)
                return ctx.bot.emit('contextError', new Errors.MissingRequiredParam(ctx, missing));
            let types = prefix_command.params.params.map(x => x.type);
            for (let i = 0; i < types.length; i++) {
                let parsed = await ctx.bot.coreback.convertParamType(args[i], prefix_command.params.params[i], ctx);
                if (parsed?.break)
                    return;
                if (prefix_command.params.params[i].long)
                    prefix_command.params.params[i].value = args.slice(i).join(' ');
                else
                    prefix_command.params.params[i].value = parsed?.value;
            }
            ctx.params = prefix_command.params.params;
        }
    }
    ctx.args = args;
    try {
        if (prefix_command)
            prefix_command.code(ctx).catch(e => ctx.bot.emit('contextError', new Errors.UnknownCommandError(ctx, e)));
    }
    catch (e) {
        ctx.bot.emit('contextError', new Errors.UnknownCommandError(ctx, e));
    }
}
async function LoadHybridCommand(ctx, hybrid_command, args) {
    if (!hybrid_command)
        return;
    ctx.command = hybrid_command;
    if (hybrid_command.plugins) {
        for (const plugin of hybrid_command.plugins) {
            if ((0, types_1.isPromise)(plugin)) {
                if (!(await (await plugin)(ctx)))
                    return;
            }
            else {
                if (!await plugin(ctx))
                    return;
            }
        }
    }
    if (hybrid_command) {
        if (hybrid_command.params) {
            let missing = hybrid_command.params.params.find((x, i) => !args[i] && x.required);
            if (missing)
                return ctx.bot.emit('contextError', new Errors.MissingRequiredParam(ctx, missing));
            let types = hybrid_command.params.params.map(x => x.type);
            for (let i = 0; i < types.length; i++) {
                let parsed = await ctx.bot.coreback.convertParamType(args[i], hybrid_command.params.params[i], ctx);
                if (parsed?.break)
                    return;
                if (hybrid_command.params.params[i].long)
                    hybrid_command.params.params[i].value = args.slice(i).join(' ');
                else
                    hybrid_command.params.params[i].value = parsed?.value;
            }
            ctx.params = hybrid_command.params.params;
        }
    }
    ctx.args = args;
    try {
        if (hybrid_command)
            hybrid_command.code(ctx).catch(e => ctx.bot.emit('contextError', new Errors.UnknownCommandError(ctx, e)));
    }
    catch (e) {
        ctx.bot.emit('contextError', new Errors.UnknownCommandError(ctx, e));
    }
}
async function LoadHybridGroup(ctx, hybrid_group, args) {
    if (!hybrid_group)
        return;
    let probably = args?.shift()?.toLowerCase();
    if (!probably)
        return;
    let sub = hybrid_group.data.commands?.find(c => c.data.name.toLowerCase() == probably || c.data.aliases.includes(probably));
    if (!sub)
        return;
    ctx.command = sub;
    ctx.parent = hybrid_group;
    LoadHybridCommand(ctx, sub, args).catch(e => ctx.bot.emit('contextError', new Errors.UnknownCommandError(new Context_1.Context(ctx.message, ctx.bot), e)));
}
const event = {
    name: 'messageCreate',
    async code(message, bot) {
        if (message.author.bot)
            return;
        let ctx = new Context_1.Context(message, bot);
        if (bot._options.guildOnly && !message.guild)
            return bot.emit('contextError', new Errors.GuildOnly(ctx));
        let prefix;
        if (typeof bot._options.prefix === 'string')
            prefix = bot._options.prefix;
        else {
            if ((0, types_1.isAsyncFunction)(bot._options.prefix))
                prefix = await bot._options.prefix(ctx);
            else
                prefix = bot._options.prefix(ctx);
        }
        if (!prefix)
            return;
        if (!message.content.toLowerCase().startsWith(prefix.toLowerCase()))
            return;
        let args = message.content.slice(prefix.length).trim().split(/ +/);
        let probably = args.shift()?.toLowerCase();
        if (!probably)
            return;
        let prefix_command = bot.skyfold.commands.PrefixType?.find(c => c.data.names.includes(probably));
        let hybrid_command = bot.skyfold.commands.HybridType?.find(c => c.data.name.toLowerCase() == probably || c.data.aliases.includes(probably));
        let hybrid_group = bot.skyfold.commands.HybridGroupType?.find(c => c.data.name.toLocaleLowerCase() == probably);
        if (!prefix_command && !hybrid_command && !hybrid_group)
            return bot.emit('contextError', new Errors.CommandNotFound(ctx, probably));
        LoadHybridGroup(ctx, hybrid_group, args).catch(e => bot.emit('contextError', new Errors.UnknownCommandError(ctx, e)));
        LoadHybridCommand(new Context_1.Context(message, bot), hybrid_command, args).catch(e => bot.emit('contextError', new Errors.UnknownCommandError(ctx, e)));
        LoadPrefixCommand(new Context_1.Context(message, bot), prefix_command, args).catch(e => bot.emit('contextError', new Errors.UnknownCommandError(ctx, e)));
    }
};
exports.event = event;
